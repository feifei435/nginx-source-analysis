1. 模块类型
#define NGX_CORE_MODULE      0x45524F43  /* "CORE" */				core/ngx_conf_file.h:
#define NGX_CONF_MODULE      0x464E4F43  /* "CONF" */				core/ngx_conf_file.h:
#define NGX_EVENT_MODULE     0x544E5645  /* "EVNT" */				event/ngx_event.h:
#define NGX_HTTP_MODULE      0x50545448  /* "HTTP" */				http/ngx_http_config.h:
#define NGX_MAIL_MODULE      0x4C49414D  /* "MAIL" */				mail/ngx_mail.h:

2. nginx把所有模块分为四类（core/event/http/mail），nginx也认为模块的上下文是四种，分别用四个结构体表示：   
	src/core/ngx_conf_file.h: 			ngx_core_module_t;
	src/mail/ngx_mail.h: 				ngx_mail_module_t;
	src/event/ngx_event.h: 				ngx_event_module_t;
	src/http/ngx_http_config.h: 		ngx_http_module_t;
	
nginx的核心类模块有7个，event类模块有10个，http类模块有47个，mail类模块有7个。另外还有一个模块是没有上下文的，是conf模块，所以准确的说nginx的模块有五种:
static ngx_core_module_t  ngx_core_module_ctx = {
static ngx_core_module_t  ngx_errlog_module_ctx = {
static ngx_core_module_t  ngx_regex_module_ctx = {
static ngx_core_module_t  ngx_events_module_ctx = {
static ngx_core_module_t  ngx_openssl_module_ctx = {
static ngx_core_module_t  ngx_http_module_ctx = {
static ngx_core_module_t  ngx_mail_module_ctx = {
static ngx_core_module_t  ngx_google_perftools_module_ctx = {

ngx_event_module_t  ngx_aio_module_ctx = { 					使用kqueue时才用到
ngx_event_module_t  ngx_devpoll_module_ctx = {
ngx_event_module_t  ngx_epoll_module_ctx = {				*** epoll ***
ngx_event_module_t  ngx_eventport_module_ctx = {
ngx_event_module_t  ngx_iocp_module_ctx = {					---WIN32
ngx_event_module_t  ngx_kqueue_module_ctx = {
ngx_event_module_t  ngx_poll_module_ctx = {
ngx_event_module_t  ngx_rtsig_module_ctx = {
ngx_event_module_t  ngx_select_module_ctx = {
ngx_win32_select_module.c(39):ngx_event_module_t  ngx_select_module_ctx = {		---WIN32




	
typedef struct {
    ngx_str_t             name;
    void               *(*create_conf)(ngx_cycle_t *cycle);
    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;


typedef struct {
    ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
    ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);

    void       *(*create_main_conf)(ngx_conf_t *cf);
    char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void       *(*create_srv_conf)(ngx_conf_t *cf);
    char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);

    void       *(*create_loc_conf)(ngx_conf_t *cf);
    char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);
} ngx_http_module_t;

typedef struct {
    ngx_str_t              *name;

    void                 *(*create_conf)(ngx_cycle_t *cycle);
    char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

    ngx_event_actions_t     actions;
} ngx_event_module_t;

 typedef struct {
    ngx_mail_protocol_t        *protocol;

    void                       *(*create_main_conf)(ngx_conf_t *cf);
    char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void                       *(*create_srv_conf)(ngx_conf_t *cf);
    char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);
} ngx_mail_module_t;
  
   
3. 模块的指令
struct ngx_command_s {
    ngx_str_t             name;						/* [analysis]   指令名称	   */		
    ngx_uint_t            type;						/* [analysis]   type是标识符集，标识指令在配置文件中的合法位置和指令的参数个数.
													 				这是一个至少有32bit的无符号整形，前16bit用于标识位置，后16bit用于标识参数 */													 
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);		/* [analysis]   函数执行解析并获取配置项值的操作 */
    ngx_uint_t            conf;						/* [analysis]   字段conf被NGX_HTTP_MODULE类型模块所用，该字段指定当前配置项所在的大致位置 */
    ngx_uint_t            offset;					/* [analysis]   解析出来的配置项值所存放的地址 */
    void                 *post;
};

指令的位域:
src/http/ngx_http_config.h:			#define NGX_HTTP_MAIN_CONF        0x02000000
src/http/ngx_http_config.h:			#define NGX_HTTP_SRV_CONF         0x04000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LOC_CONF         0x08000000
src/http/ngx_http_config.h:			#define NGX_HTTP_UPS_CONF         0x10000000
src/http/ngx_http_config.h:			#define NGX_HTTP_SIF_CONF         0x20000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LIF_CONF         0x40000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LMT_CONF         0x80000000
src/mail/ngx_mail.h:				#define NGX_MAIL_MAIN_CONF        0x02000000
src/mail/ngx_mail.h:				#define NGX_MAIL_SRV_CONF         0x04000000
src/core/ngx_conf_file.h:			#define NGX_DIRECT_CONF      	  0x00010000
src/core/ngx_conf_file.h:			#define NGX_MAIN_CONF        	  0x01000000
src/core/ngx_conf_file.h:			#define NGX_ANY_CONF         	  0x0F000000
src/event/ngx_event.h:				#define NGX_EVENT_CONF        	  0x02000000
   
   
4. 模块的配置结构 (命名格式为:ngx_*_conf_t)
src/core/ngx_cycle.h:	 											ngx_core_conf_t;
src/mail/ngx_mail_ssl_module.h:	 									ngx_mail_ssl_conf_t;
src/mail/ngx_mail_imap_module.h:     								ngx_mail_imap_srv_conf_t;
src/mail/ngx_mail_pop3_module.h:     								gx_mail_pop3_srv_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_addr_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_core_main_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_core_srv_conf_t;
src/mail/ngx_mail_smtp_module.h:     								ngx_mail_smtp_srv_conf_t;
src/event/ngx_event.h:     											ngx_event_conf_t;
src/http/ngx_http_core_module.h:typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;
src/http/ngx_http_core_module.h:     								ngx_http_core_main_conf_t;
src/http/ngx_http_core_module.h:    								ngx_http_core_srv_conf_t;
src/http/ngx_http_core_module.h:     								ngx_http_addr_conf_t;
src/http/modules/ngx_http_ssi_filter_module.h:	 					ngx_http_ssi_main_conf_t;
src/http/modules/ngx_http_ssl_module.h:	 							ngx_http_ssl_srv_conf_t;
src/http/ngx_http_upstream.h:	 									ngx_http_upstream_main_conf_t;
src/http/ngx_http_upstream.h:typedef struct ngx_http_upstream_srv_conf_s  ngx_http_upstream_srv_conf_t;
src/http/ngx_http_upstream.h:	 									ngx_http_upstream_conf_t;  
   
   
   
   
5. 信号
通过nginx -s 命令行方式指定的信号只有
stop	停止(快速停止不保存相关信息)
quit	停止(quit是一种优雅的停止，也就是进程如果还在服务中，那么就不会关闭该进程，直到进程完成服务为止。当然这个过程中不能再接受新的任务了)
reopen	重新打开日志文件
reload  当修改了配置文件以后，需要重新加载配置文件(平滑重启) 
可以通过查看ngx_process.c:	ngx_signal_t  signals[]数组, 定义了信号处理的方式。

共监控12个信号，这些信号均可以通过kill命令向master进程发送(其中两个忽略，其他均执行ngx_signal_handler).
SIGHUP 	- 平滑重启(reload)
SIGUSR1 - 重新打开日志文件(reopen)
SIGWINCH - 从容关闭工作进程   
SIGTERM - stop  
SIGQUIT - quit  
SIGUSR2 - 平滑升级可执行程序
SIGALRM - 
SIGINT -
SIGIO - 
SIGCHLD - 
SIGSYS - 
SIGPIPE -
   
=================== 启动初始化流程 =====================      
ngx_strerror_init();
ngx_get_options(argc, argv);
ngx_time_init();
ngx_regex_init();
ngx_log_init(ngx_prefix);   
ngx_ssl_init(log);
初始化init_cycle
ngx_save_argv(&init_cycle, argc, argv)
ngx_process_options(&init_cycle)			//	设置cycle变量
ngx_os_init(log)
ngx_crc32_table_init();
ngx_add_inherited_sockets(&init_cycle);
ngx_init_cycle(&init_cycle);
   
   
=================== ngx_init_cycle()流程 =====================   
ngx_timezone_update();
ngx_time_update();   


 EVENT解析配置文件
 ngx_events_block(对event模块进行点数, 确认模块类型中的序号)
	|__create_conf
	|__init_conf
		|__先获取模块上下文(定位ngx_epoll_module模块), 设置模块类型的序号
		
		
worker进程初始化时，调用所有模块的init_process(ngx_event_process_init), 根据init_conf中设置的模块类型序号查找到ngx_epoll_module模块后(ngx_event_module_t), 调用->actions.init(ngx_epoll_init)

    select - 标准方法。 如果当前平台没有更有效的方法，它是编译时默认的方法。你可以使用配置参数 --with-select_module 和 --without-select_module 来启用或禁用这个模块。
    poll - 标准方法。 如果当前平台没有更有效的方法，它是编译时默认的方法。你可以使用配置参数 --with-poll_module 和 --without-poll_module 来启用或禁用这个模块。
    kqueue - 高效的方法，使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X. 使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。
    epoll - 高效的方法，使用于Linux内核2.6版本及以后的系统。在某些发行版本中，如SuSE 8.2, 有让2.4版本的内核支持epoll的补丁。
    rtsig - 可执行的实时信号，使用于Linux内核版本2.2.19以后的系统。默认情况下整个系统中不能出现大于1024个POSIX实时(排队)信号。这种情况对于高负载的服务器来说是低效的；所以有必要通过调节内核参数 /proc/sys/kernel/rtsig-max 来增加队列的大小。可是从Linux内核版本2.6.6-mm2开始， 这个参数就不再使用了，并且对于每个进程有一个独立的信号队列，这个队列的大小可以用 RLIMIT_SIGPENDING 参数调节。当这个队列过于拥塞，nginx就放弃它并且开始使用 poll 方法来处理连接直到恢复正常。
    /dev/poll - 高效的方法，使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+.
    eventport - 高效的方法，使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装 这个 安全补丁。 

	
ngx_event_accept(有请求来到)
	|__ngx_http_init_connection(初始化连接，加入读事件到epoll中)
		|__ngx_http_init_request(此连接有读事件到来时调用)	
		
		
=================== http配置块解析流程 =====================   		
ngx_http_block(配置文件中遇见http时将会调用)
	|__为ngx_http_conf_ctx_t申请空间，并为所有字段申请空间，每个字段指向http模块的一个配置结构
		|__调用所有模块的create_main_conf
		|__调用所有模块的create_srv_conf
		|__调用所有模块的create_loc_conf
	|__调用所有模块的preconfiguration回调
	|__调用ngx_conf_parse解析所有http配置项	（解析http {...} block里的所有内容，解析完成后返回）
	|__调用所有模块的init_main_conf回调																	
	|__ngx_http_merge_servers调用模块的merge_srv_conf 和 merge_loc_conf 两个handler处理函数				
	|__ngx_http_init_locations																			
	|__ngx_http_init_static_location_trees
	|__ngx_http_init_phases
	|__ngx_http_init_headers_in_hash
	|__调用所有模块的postconfiguration
	|__ngx_http_variables_init_vars
	|__ngx_http_init_phase_handlers
	|__ngx_http_optimize_servers

---------------模块的配置handler执行流程-------------------------
create_main_conf
create_srv_conf
create_loc_conf
preconfiguration			//	大多数是设置variables变量
init_main_conf				//	对create_main_conf中的字段初始化
merge_srv_conf
merge_loc_conf
postconfiguration			//	设置相应阶段的handler

ngx_http_core_server(配置文件中遇见server时将会调用)
	|__ngx_http_conf_ctx_t申请空间(其中两个字段申请空间，ctx->srv_conf 和 ctx->loc_conf )
	|__调用各个模块的 create_srv_conf 和 create_loc_conf 并赋值到ctx上
	|__设置ngx_http_core_srv_conf_t中的ctx字段
	|__向ngx_http_core_main_conf_t中的servers数组字段中添加 ngx_http_core_srv_conf_t 结构元素
	|__ngx_conf_parse()
	
ngx_http_core_location(配置文件中遇见location时将会调用)
	|__创建本级的location, main和srv的conf均使用ngx_http_core_server()函数中创建的
	|__

在这几个phase的checker中，它将所要执行的handler的返回值分为4种类型。
1 NGX_OK 此时返回NGX_AGAIN,这里我们知道如果checker返回ok的话，整个handler的处理就会直接返回，也就是这次处理结束。并且这里phase_handler被赋值为ph->next,也就是下一个phase的索引。也就是说下次将会调用它的下一个phase的checker。

2 NGX_DECLINED 此时也返回NGX_AGAIN,而这个和上面有所不同，那就是phase_handler的赋值，这里这个值只是简单的++,也就是说会紧接着处理当前phase的下一个phase，只有当前的phase的handelr处理完毕了，才可能会处理下一个phase的handler

3 NGX_AGAIN 或者NGX_DONE，这个的话直接返回OK,也就是会结束handler的处理。

4 剩余的情况，主要是处理NGX_ERROR,以及NGX_HTTP_(也就是返回一些http的状态码)的处理。 	
	
--------------- phase的checker -------------------------	
NGX_HTTP_POST_READ_PHASE					ngx_http_core_generic_phase
NGX_HTTP_SERVER_REWRITE_PHASE				ngx_http_core_rewrite_phase
NGX_HTTP_FIND_CONFIG_PHASE					ngx_http_core_find_config_phase
NGX_HTTP_REWRITE_PHASE						ngx_http_core_rewrite_phase
NGX_HTTP_POST_REWRITE_PHASE					ngx_http_core_post_rewrite_phase
NGX_HTTP_PREACCESS_PHASE					ngx_http_core_generic_phase
NGX_HTTP_ACCESS_PHASE						ngx_http_core_access_phase
NGX_HTTP_POST_ACCESS_PHASE					ngx_http_core_post_access_phase
NGX_HTTP_TRY_FILES_PHASE					ngx_http_core_try_files_phase
NGX_HTTP_CONTENT_PHASE						ngx_http_core_content_phase
NGX_HTTP_LOG_PHASE							ngx_http_core_generic_phase	


NGX_HTTP_POST_READ_PHASE		------|	
									  |
NGX_HTTP_SERVER_REWRITE_PHASE	<-----|

NGX_HTTP_FIND_CONFIG_PHASE		<-----|	<----|		
											 |
NGX_HTTP_REWRITE_PHASE				  |		 |
									  |		 |
NGX_HTTP_POST_REWRITE_PHASE		<-----|		 |
									  |------| 	
NGX_HTTP_PREACCESS_PHASE		
NGX_HTTP_ACCESS_PHASE			
NGX_HTTP_POST_ACCESS_PHASE		
NGX_HTTP_TRY_FILES_PHASE		
NGX_HTTP_CONTENT_PHASE			
NGX_HTTP_LOG_PHASE				



这里需要注意就是只有下面这几个phase会有多个handler:
		NGX_HTTP_POST_READ_PHASE   
        NGX_HTTP_SERVER_REWRITE_PHASE,  
        NGX_HTTP_REWRITE_PHASE,  
        NGX_HTTP_PREACCESS_PHASE,  
        NGX_HTTP_ACCESS_PHASE,  
        NGX_HTTP_CONTENT_PHASE,  
        NGX_HTTP_LOG_PHASE  
剩余的都是只有一个handler的:
		NGX_HTTP_FIND_CONFIG_PHASE	
		NGX_HTTP_POST_REWRITE_PHASE
		NGX_HTTP_POST_ACCESS_PHASE
		NGX_HTTP_TRY_FILES_PHASE
		
--------------- 请求处理流程 -------------------------			
ngx_http_init_connection
	|__ngx_http_init_request
		|__ngx_http_process_request_line
			|__ngx_http_read_request_header(读取request line)
			|__ngx_http_parse_request_line(解析request line)
			|__ngx_http_process_request_headers(解析request headers)
				|__ngx_http_read_request_header(读取request header)
				|__ngx_http_parse_header_line(解析request header)
				|__ngx_http_process_request_header
				|__ngx_http_process_request
					|__ngx_http_handler
						|__ngx_http_core_run_phases
					|__ngx_http_run_posted_requests
					
					
					
---------------------http-variables变量---------------------
ngx_http_core_variables静态数组中的所有变量加入到 ngx_http_core_main_conf_t的 ngx_hash_keys_arrays_t    *variables_keys;字段
												  ngx_http_core_main_conf_t的 ngx_hash_t                 variables_hash;字段


		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
   
   
   
   
   
   
   
   
   
   
   