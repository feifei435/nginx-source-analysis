1. 模块类型
#define NGX_CORE_MODULE      0x45524F43  /* "CORE" */				core/ngx_conf_file.h:
#define NGX_CONF_MODULE      0x464E4F43  /* "CONF" */				core/ngx_conf_file.h:
#define NGX_EVENT_MODULE     0x544E5645  /* "EVNT" */				event/ngx_event.h:
#define NGX_HTTP_MODULE      0x50545448  /* "HTTP" */				http/ngx_http_config.h:
#define NGX_MAIL_MODULE      0x4C49414D  /* "MAIL" */				mail/ngx_mail.h:

2. nginx把所有模块分为四类（core/event/http/mail），nginx也认为模块的上下文是四种，分别用四个结构体表示：   
	src/core/ngx_conf_file.h: 			ngx_core_module_t;
	src/mail/ngx_mail.h: 				ngx_mail_module_t;
	src/event/ngx_event.h: 				ngx_event_module_t;
	src/http/ngx_http_config.h: 		ngx_http_module_t;
	
nginx的核心类模块有7个，event类模块有10个，http类模块有47个，mail类模块有7个。另外还有一个模块是没有上下文的，是conf模块，所以准确的说nginx的模块有五种:
static ngx_core_module_t  ngx_core_module_ctx = {
static ngx_core_module_t  ngx_errlog_module_ctx = {
static ngx_core_module_t  ngx_regex_module_ctx = {
static ngx_core_module_t  ngx_events_module_ctx = {
static ngx_core_module_t  ngx_openssl_module_ctx = {
static ngx_core_module_t  ngx_http_module_ctx = {
static ngx_core_module_t  ngx_mail_module_ctx = {
static ngx_core_module_t  ngx_google_perftools_module_ctx = {

ngx_event_module_t  ngx_aio_module_ctx = { 					使用kqueue时才用到
ngx_event_module_t  ngx_devpoll_module_ctx = {
ngx_event_module_t  ngx_epoll_module_ctx = {				*** epoll ***
ngx_event_module_t  ngx_eventport_module_ctx = {
ngx_event_module_t  ngx_iocp_module_ctx = {					---WIN32
ngx_event_module_t  ngx_kqueue_module_ctx = {
ngx_event_module_t  ngx_poll_module_ctx = {
ngx_event_module_t  ngx_rtsig_module_ctx = {
ngx_event_module_t  ngx_select_module_ctx = {
ngx_win32_select_module.c(39):ngx_event_module_t  ngx_select_module_ctx = {		---WIN32




	
typedef struct {
    ngx_str_t             name;
    void               *(*create_conf)(ngx_cycle_t *cycle);
    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;


typedef struct {
    ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
    ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);

    void       *(*create_main_conf)(ngx_conf_t *cf);
    char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void       *(*create_srv_conf)(ngx_conf_t *cf);
    char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);

    void       *(*create_loc_conf)(ngx_conf_t *cf);
    char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);
} ngx_http_module_t;

typedef struct {
    ngx_str_t              *name;

    void                 *(*create_conf)(ngx_cycle_t *cycle);
    char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

    ngx_event_actions_t     actions;
} ngx_event_module_t;

 typedef struct {
    ngx_mail_protocol_t        *protocol;

    void                       *(*create_main_conf)(ngx_conf_t *cf);
    char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void                       *(*create_srv_conf)(ngx_conf_t *cf);
    char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);
} ngx_mail_module_t;
  
   
3. 模块的指令
struct ngx_command_s {
    ngx_str_t             name;						/* [analysis]   指令名称	   */		
    ngx_uint_t            type;						/* [analysis]   type是标识符集，标识指令在配置文件中的合法位置和指令的参数个数.
													 				这是一个至少有32bit的无符号整形，前16bit用于标识位置，后16bit用于标识参数 */													 
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);		/* [analysis]   函数执行解析并获取配置项值的操作 */
    ngx_uint_t            conf;						/* [analysis]   字段conf被NGX_HTTP_MODULE类型模块所用，该字段指定当前配置项所在的大致位置 */
    ngx_uint_t            offset;					/* [analysis]   解析出来的配置项值所存放的地址 */
    void                 *post;
};

指令的位域:
src/http/ngx_http_config.h:			#define NGX_HTTP_MAIN_CONF        0x02000000
src/http/ngx_http_config.h:			#define NGX_HTTP_SRV_CONF         0x04000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LOC_CONF         0x08000000
src/http/ngx_http_config.h:			#define NGX_HTTP_UPS_CONF         0x10000000
src/http/ngx_http_config.h:			#define NGX_HTTP_SIF_CONF         0x20000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LIF_CONF         0x40000000
src/http/ngx_http_config.h:			#define NGX_HTTP_LMT_CONF         0x80000000
src/mail/ngx_mail.h:				#define NGX_MAIL_MAIN_CONF        0x02000000
src/mail/ngx_mail.h:				#define NGX_MAIL_SRV_CONF         0x04000000
src/core/ngx_conf_file.h:			#define NGX_DIRECT_CONF      	  0x00010000
src/core/ngx_conf_file.h:			#define NGX_MAIN_CONF        	  0x01000000
src/core/ngx_conf_file.h:			#define NGX_ANY_CONF         	  0x0F000000
src/event/ngx_event.h:				#define NGX_EVENT_CONF        	  0x02000000
   
   
4. 模块的配置结构 (命名格式为:ngx_*_conf_t)
src/core/ngx_cycle.h:	 											ngx_core_conf_t;
src/mail/ngx_mail_ssl_module.h:	 									ngx_mail_ssl_conf_t;
src/mail/ngx_mail_imap_module.h:     								ngx_mail_imap_srv_conf_t;
src/mail/ngx_mail_pop3_module.h:     								gx_mail_pop3_srv_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_addr_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_core_main_conf_t;
src/mail/ngx_mail.h:     											ngx_mail_core_srv_conf_t;
src/mail/ngx_mail_smtp_module.h:     								ngx_mail_smtp_srv_conf_t;
src/event/ngx_event.h:     											ngx_event_conf_t;
src/http/ngx_http_core_module.h:typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;
src/http/ngx_http_core_module.h:     								ngx_http_core_main_conf_t;
src/http/ngx_http_core_module.h:    								ngx_http_core_srv_conf_t;
src/http/ngx_http_core_module.h:     								ngx_http_addr_conf_t;
src/http/modules/ngx_http_ssi_filter_module.h:	 					ngx_http_ssi_main_conf_t;
src/http/modules/ngx_http_ssl_module.h:	 							ngx_http_ssl_srv_conf_t;
src/http/ngx_http_upstream.h:	 									ngx_http_upstream_main_conf_t;
src/http/ngx_http_upstream.h:typedef struct ngx_http_upstream_srv_conf_s  ngx_http_upstream_srv_conf_t;
src/http/ngx_http_upstream.h:	 									ngx_http_upstream_conf_t;  
   
   
   
   
5. 信号
通过nginx -s 命令行方式指定的信号只有
stop	停止(快速停止不保存相关信息)
quit	停止(quit是一种优雅的停止，也就是进程如果还在服务中，那么就不会关闭该进程，直到进程完成服务为止。当然这个过程中不能再接受新的任务了)
reopen	重新打开日志文件
reload  当修改了配置文件以后，需要重新加载配置文件(平滑重启) 
可以通过查看ngx_process.c:	ngx_signal_t  signals[]数组, 定义了信号处理的方式。

共监控12个信号，这些信号均可以通过kill命令向master进程发送(其中两个忽略，其他均执行ngx_signal_handler).
SIGHUP 	- 平滑重启(reload)
SIGUSR1 - 重新打开日志文件(reopen)
SIGWINCH - 从容关闭工作进程   
SIGTERM - stop  
SIGQUIT - quit  
SIGUSR2 - 平滑升级可执行程序
SIGALRM - 
SIGINT -
SIGIO - 
SIGCHLD - 
SIGSYS - 
SIGPIPE -
   
=================== 启动初始化流程 =====================      
ngx_strerror_init();
ngx_get_options(argc, argv);
ngx_time_init();
ngx_regex_init();
ngx_log_init(ngx_prefix);   
ngx_ssl_init(log);
初始化init_cycle
ngx_save_argv(&init_cycle, argc, argv)
ngx_process_options(&init_cycle)			//	设置cycle变量
ngx_os_init(log)
ngx_crc32_table_init();
ngx_add_inherited_sockets(&init_cycle);
ngx_init_cycle(&init_cycle);
   
   
=================== ngx_init_cycle()流程 =====================   
ngx_timezone_update();
ngx_time_update();   


 EVENT解析配置文件
 ngx_events_block(对event模块进行点数, 确认模块类型中的序号)
	|__create_conf
	|__init_conf
		|__先获取模块上下文(定位ngx_epoll_module模块), 设置模块类型的序号
		
		
worker进程初始化时，调用所有模块的init_process(ngx_event_process_init), 根据init_conf中设置的模块类型序号查找到ngx_epoll_module模块后(ngx_event_module_t), 调用->actions.init(ngx_epoll_init)

    select - 标准方法。 如果当前平台没有更有效的方法，它是编译时默认的方法。你可以使用配置参数 --with-select_module 和 --without-select_module 来启用或禁用这个模块。
    poll - 标准方法。 如果当前平台没有更有效的方法，它是编译时默认的方法。你可以使用配置参数 --with-poll_module 和 --without-poll_module 来启用或禁用这个模块。
    kqueue - 高效的方法，使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X. 使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。
    epoll - 高效的方法，使用于Linux内核2.6版本及以后的系统。在某些发行版本中，如SuSE 8.2, 有让2.4版本的内核支持epoll的补丁。
    rtsig - 可执行的实时信号，使用于Linux内核版本2.2.19以后的系统。默认情况下整个系统中不能出现大于1024个POSIX实时(排队)信号。这种情况对于高负载的服务器来说是低效的；所以有必要通过调节内核参数 /proc/sys/kernel/rtsig-max 来增加队列的大小。可是从Linux内核版本2.6.6-mm2开始， 这个参数就不再使用了，并且对于每个进程有一个独立的信号队列，这个队列的大小可以用 RLIMIT_SIGPENDING 参数调节。当这个队列过于拥塞，nginx就放弃它并且开始使用 poll 方法来处理连接直到恢复正常。
    /dev/poll - 高效的方法，使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+.
    eventport - 高效的方法，使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装 这个 安全补丁。 

	
ngx_event_accept(有请求来到)
	|__ngx_http_init_connection(初始化连接，加入读事件到epoll中)
		|__ngx_http_init_request(此连接有读事件到来时调用)	
   
   
   
   
   
   
   
   
   
   
   